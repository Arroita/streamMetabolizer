model {
  
  # DAY-SPECIFIC PARAMETERS
  for(d in 1:nday) {
    
    # Daily mean values of GPP and ER (gO2 m^-2 d^-1)
    GPP.daily[d] ~ dnorm(GPP.daily.mu, pow(GPP.daily.sigma, -2))
    ER.daily[d] ~ dnorm(ER.daily.mu, pow(ER.daily.sigma, -2))
    
    # Linear relationship between K600 (m d^-1) and daily, standardized, centered, logged Q
    K600.daily[d] ~ dnorm(KQ.icpt + KQ.slope*log(standardize(center(Q))), K600.daily.tau)

    # Convert daily rates to per-observation rates
    for(i in 1:n[d]) {
      GPP[i,d] <- GPP.daily[d] * frac.GPP[i,d] / depth[i,d]
      ER[i,d] <- ER.daily[d] * frac.ER[i,d] / depth[i,d]
      K[i,d] <- K600.daily[d] * KO2.conv[i,d] * frac.D[i,d]
    }
    
    # Set up initial DO.mod and err.proc for the day
    DO.mod[1,d] <- DO.obs[1,d]
    err.proc[1,d] <- 0

    # TIMESTEP-SPECIFIC PARAMETERS
    for(i in 2:n[d]) {
      # Model DO changes as in Hotchkiss & Hall 2014, eq. 2
      DO.mod[i,d] <- DO.mod[i-1,d] +
        GPP[i,d] + 
        ER[i,d] + 
        K[i,d] * (DO.sat[i,d] - DO.mod[i-1,d]) +
        err.proc[i,d]

      # Process error: Build an error timeseries with a fitted autocorrelation structure
      err.proc[i,d] ~ dnorm(err.proc.phi*err.proc[i-1,d], pow(err.proc.sigma, -2))
  
      # Observation error: Compare all the DO predictions to their observations
      DO.obs[i,d] ~ dnorm(DO.mod[i,d], pow(err.obs.sigma, -2))
   
    }
  }
  
  # TIME-INDEPENDENT PARAMETERS
  
  # Prior on the sd of the errors between modeled and observed DO
  err.obs.sigma ~ dunif(0, 0.5)

  # Prior on the autocorrelation & sd of the process errors
  err.proc.phi <- 1
  err.proc.sigma ~ dunif(0, 0.5)

  # Priors on the intercept and slope of the K ~ Q relationshipo
  KQ.icpt ~ dnorm(3, 1)
  KQ.slope ~ dnorm(0, 1)
  
  # Supplied by the input
  # GPP.daily.mu, GPP.daily.sigma
  # ER.daily.mu, ER.daily.sigma

}

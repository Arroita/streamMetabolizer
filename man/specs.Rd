% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/specs.R
\name{specs}
\alias{specs}
\title{Generate a coherent list of model specs}
\usage{
specs(model_name = mm_name(), GPP_init = 10, ER_init = -10,
  K600_init = 10, calc_DO_fun, ODE_method, bayes_fun, bayes_software,
  keep_mcmcs = TRUE, GPP_daily_mu = 10, GPP_daily_sigma = 10,
  ER_daily_mu = -10, ER_daily_sigma = 10, K600_daily_mu = 10,
  K600_daily_sigma = 10, err_obs_iid_sigma_min = 0,
  err_obs_iid_sigma_max = 5, err_proc_acor_phi_min = 0,
  err_proc_acor_phi_max = 1, err_proc_acor_sigma_min = 0,
  err_proc_acor_sigma_max = 5, err_proc_iid_sigma_min = 0,
  err_proc_iid_sigma_max = 5, priors = FALSE, params_out, n_chains = 4,
  n_cores = 4,
  adapt_steps = switch(mm_parse_name(model_name)$bayes_software, jags = 250,
  NA), burnin_steps = switch(mm_parse_name(model_name)$bayes_software, stan =
  500, jags = 250, NA),
  saved_steps = switch(mm_parse_name(model_name)$bayes_software, stan = 500,
  jags = 1000, NA), thin_steps = 1, verbose = FALSE, err.obs.sigma = 0.1,
  err.obs.phi = 0, err.proc.sigma = 0, err.proc.phi = 0, sim.seed = NA)
}
\arguments{
\item{model_name}{character string identifying the model features. Use 
\code{\link{mm_name}} for valid names. This may be a full model file path 
for custom Bayesian models, as long as basename(model_name) can still be 
parsed correctly with \code{mm_parse_name()}. In that case the file may be 
specified either as a file path relative to the streamMetabolizer models 
directory (the first assumption; this directory can be found with 
\code{system.file("models", package="streamMetabolizer")}) or as an 
absolute path or a path relative to the current working directory (the 
second assumption, if the first assumption turns up no files of the given 
name).}

\item{GPP_init}{the inital value of daily GPP to use in the NLM fitting 
process}

\item{ER_init}{the inital value of daily ER to use in the NLM fitting process}

\item{K600_init}{the inital value of daily K600 to use in the NLM fitting 
process. Ignored if K600 is supplied in data_daily, except for those dates 
where K600 is NA. If there are any such dates, K600_init must have a 
numeric (non-NA) value, as this will be used to estimate K600 for those 
dates.}

\item{calc_DO_fun}{the function to use to build DO estimates from GPP, ER, 
etc. default is calc_DO_mod, but could also be calc_DO_mod_by_diff}

\item{ODE_method}{character specifying the numerical integration method to 
use. The default is pairmeans, where the change in DO between times t-1 and
t is a function of the mean DO.sat between times t-1 and t, mean temp.water
between times t-1 and t, mean light between times t-1 and t, etc. The Euler
method is currently more common in the literature, with each time step 
depending entirely on DO.sat, GPP, etc. at time t. Both methods are
imprecise and fast, relative to Runge-Kutta or other numerical integration
methods}

\item{bayes_fun}{character in \code{c('bayes_1ply', 'bayes_all')} indicating 
whether the data should be split into daily chunks first ('bayes_1ply') or 
passed to the model fitting function in one big chunk ('bayes_all')}

\item{bayes_software}{character in \code{c('jags','stan')} indicating the 
software package to use for the MCMC process}

\item{keep_mcmcs}{TRUE, FALSE, or (for nopool models) a vector of dates 
(coerced with as.Date if character, etc.) indicating whether to keep all of
the mcmc model objects (TRUE), none of them (FALSE), or specific dates. The
default is FALSE because these objects can be very large.}

\item{GPP_daily_mu}{The mean of a dnorm distribution for GPP_daily, the daily
rate of gross primary production}

\item{GPP_daily_sigma}{The standard deviation of a dnorm distribution for 
GPP_daily, the daily rate of gross primary production}

\item{ER_daily_mu}{The mean of a dnorm distribution for ER_daily, the daily 
rate of ecosystem respiration}

\item{ER_daily_sigma}{The standard deviation of a dnorm distribution for 
ER_daily, the daily rate of ecosystem respiration}

\item{K600_daily_mu}{The mean of a dnorm distribution for K600_daily, the 
daily rate of reaeration}

\item{K600_daily_sigma}{The standard deviation of a dnorm distribution for 
K600_daily, the daily rate of reaeration}

\item{err_obs_iid_sigma_min}{The lower bound on a dunif distribution for 
err_obs_iid_sigma, the standard deviation of the observation error}

\item{err_obs_iid_sigma_max}{The upper bound on a dunif distribution for 
err_obs_iid_sigma, the standard deviation of the observation error}

\item{err_proc_acor_phi_min}{lower bound on the autocorrelation coefficient 
for the autocorrelated component of process [& sometimes observation] error}

\item{err_proc_acor_phi_max}{upper bound on the autocorrelation coefficient 
for the autocorrelated component of process [& sometimes observation] error}

\item{err_proc_acor_sigma_min}{lower bound on the standard deviation of the 
autocorrelated component of process [& sometimes observation] error}

\item{err_proc_acor_sigma_max}{upper bound on the standard deviation of the 
autocorrelated component of process [& sometimes observation] error}

\item{err_proc_iid_sigma_min}{lower bound on the standard deviation of the 
uncorrelated (IID) component of process [& sometimes observation] error}

\item{err_proc_iid_sigma_max}{upper bound on the standard deviation of the 
uncorrelated (IID) component of process [& sometimes observation] error}

\item{priors}{logical. Should the data list be modified such that JAGS will 
return priors rather than posteriors?}

\item{params_out}{a character vector of parameters whose values in the MCMC 
runs should be recorded and summarized}

\item{n_chains}{the number of chains to run}

\item{n_cores}{the number of cores to apply to this run}

\item{adapt_steps}{the number of steps per chain to use in adapting the model}

\item{burnin_steps}{the number of steps per chain to run and ignore before
starting to collect MCMC 'data'}

\item{saved_steps}{the number of MCMC steps per chain to save}

\item{thin_steps}{the number of steps to move before saving another step. 1
means save all steps.}

\item{verbose}{logical. give status messages?}

\item{err.obs.sigma}{The sd of observation error, or 0 for no observation 
error. Observation errors are those applied to DO.mod after generating the 
full time series of modeled values.}

\item{err.obs.phi}{The autocorrelation coefficient of the observation errors,
or 0 for uncorrelated errors.}

\item{err.proc.sigma}{The sd of process error, or 0 for no process error. 
Process errors are applied at each time step, and therefore propagate into 
the next timestep.}

\item{err.proc.phi}{The autocorrelation coefficient of the process errors, or
0 for uncorrelated errors.}

\item{sim.seed}{NA to specify that each call to predict_DO should generate 
new values, or an integer, as in the \code{seed} argument to 
\code{\link{set.seed}}, specifying the seed to set before every execution 
of predict_DO}
}
\value{
an internally consistent list of arguments that may be passed to 
  \code{metab_bayes}, \code{metab_mle}, etc. as the \code{model_specs} 
  argument
}
\description{
Generates an internally consistent list of model specifications that may be 
passed to \code{metab_bayes}, \code{metab_mle}, etc. via the 
\code{model_specs} argument. This help file gives the definitive list of all 
possible model specs, but only a subset of these are relevant to any given 
\code{model_name}. See the 'Relevant arguments' section below. Irrelevant 
arguments for the given \code{model_name} should not be explicitly passed 
into this function (but don't worry - we'll just stop and tell you if you 
make a mistake). Relevant arguments for the given \code{model_name} either 
have default values or do not (see Usage). Relevant arguments without a 
default should rarely be overridden, because their values will be determined 
based on other arguments. Relevant arguments that do have a default can, and 
often should, be overridden to tailor the model to your needs.
}
\section{Relevant arguments}{

  
  * metab_bayes: Always relevant: \code{model_name, bayes_fun, 
  bayes_software, keep_mcmcs, GPP_daily_mu, GPP_daily_sigma, ER_daily_mu, 
  ER_daily_sigma, K600_daily_mu, K600_daily_sigma, priors, params_out, 
  n_chains, n_cores, burnin_steps, saved_steps, thin_steps, verbose}. If 
  \code{mm_parse_name(model_name)$err_obs_iid} then also 
  \code{err_obs_iid_sigma_min, err_obs_iid_sigma_max}. If 
  \code{mm_parse_name(model_name)$err_proc_acor} then also 
  \code{err_proc_acor_phi_min, err_proc_acor_phi_max, 
  err_proc_acor_sigma_min, err_proc_acor_sigma_max}. If 
  \code{mm_parse_name(model_name)$err_proc_iid} then also 
  \code{err_proc_iid_sigma_min, err_proc_iid_sigma_max}. If 
  \code{features$bayes_software == 'jags'} then also \code{adapt_steps},
  
  * metab_mle: \code{model_name, calc_DO_fun, ODE_method, GPP_init, ER_init, 
  K600_init}
  
  * metab_night: \code{model_name}
  
  * metab_sim: \code{model_name, err.obs.sigma, err.obs.phi, err.proc.sigma, 
  err.proc.phi, ODE_method, sim.seed}
}
\examples{
specs(mm_name(type='bayes', err_obs_iid=TRUE, err_proc_acor=TRUE))
  
}


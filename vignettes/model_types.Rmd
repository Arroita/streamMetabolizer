---
title: "Metabolism Model Options"
author: "Alison Appling"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Metabolism Model Options}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE}
suppressPackageStartupMessages(library(streamMetabolizer))
```

## Model Types

streamMetabolizer provides many options for customizing your metabolism model. At a very high level, these are grouped by their fitting method. Each fitting method has its own fitting function; see the `metab_fun` column of `metab_funs()` for a complete list.
```{r}
metab_funs()
```
It is most common to use `metab_bayes` or `metab_mle`.

## Model Arguments

A few modeling options are directly specified as arguments to the fitting functions. These typically include `data`, `data_daily`, `info`, `day_start`, `day_end`, and `tests`. See the fitting function help files, e.g., `?metab_mle`, for more details.
```{r, eval=FALSE}
?metab_mle
```

## Specification Groups

All the rest of the modeling options are contained within a single argument, `model_specs` (where `specs` is short for 'specifications'). `model_specs` is just an R list and could therefore be defined manually, but it's a long list whose elements depend on the modeling approach you're taking. To simplify the process of setting these specifications, we've therefore defined a function called `specs` to generate the list for you. This function uses a model name to determine which arguments need to be supplied, then produces a list of mutually compatible default specifications. We'll show how to find your model name below; for now, commonly used model names include `m_np_oi_pm_km.nlm` (for a simple MLE model) and `b_np_oi_pm_km.stan` (for a simple Bayesian model). To give you a taste of the resulting specifications lists while keeping the output short, we'll just print the list element names here:
```{r}
names(specs('m_np_oi_pm_km.nlm'))
names(specs('b_np_oi_pm_km.stan'))
```

Once defined, an options list can be passed directly to the corresponding `metab_` function to run your model. The appropriate `metab_` function is the one whose name matches the model name passed to `specs`; e.g., `specs('b_...')` functions should be used within `metab_bayes()` calls, and `specs('m_...')` functions should be used within `metab_mle()` calls.
```{r, eval=FALSE}
fit <- metab_mle(data=mydat, model_specs=specs_mle_nopool_oi())
```

You can override the defaults by passing values to the `specs` function; see the `specs` help file at `?specs` for the list of possible options and their definitions. To see which options apply to your model, read the details of the help file or just print out a dummy version with all the defaults
```{r, eval=FALSE}
?specs
# dummy version to see what's available to override
specs('m_np_oi_pm_km.nlm')
# override some defaults
fit <- metab_mle(data=mydat, model_specs=specs('m_np_oi_pm_km.nlm', GPP_init=7, K600_init=35))
```


## Choosing a Model Name

Model names define aspects of the modeling approach such as the degree of hierarchy in the model, additional software or packages to employ, and the types of error to model. To find the model name you want, you can generate the model name from the traits you want. See `?mm_name` for model traits you can search. The return value is a data.frame with all rows matching the traits you selected, where the `specs_fun` column contains specification function names.
```{r, eval=2}
?mm_name
mm_name(type="bayes", engine="jags", pooling='none', err_obs_iid=TRUE)
```


## Specification Group Types

Here is the full set of accepted model names and their traits.

```{r, echo=FALSE, results='asis'}
opts <- do.call('expand.grid', c(as.list(formals(mm_name)), list(stringsAsFactors=FALSE)))
attr(opts, 'out.attrs') <- NULL
opt_names <- sapply(1:nrow(opts), function(opt) tryCatch(do.call(mm_name, opts[opt,]), error=function(e) NA))
opts <- opts[!is.na(opt_names),]
opt_names <- opt_names[!is.na(opt_names)]

opt_parsed <- mm_parse_name(opt_names)
opt_ok <- sapply(opt_names, function(opt) tryCatch({specs(opt); TRUE}, warning=function(w) if(mm_parse_name(opt)$type=='bayes') FALSE else TRUE, error=function(e) FALSE))
opts <- opts[opt_ok, ]
rownames(opts) <- NULL
opt_names <- opt_names[opt_ok]

suppressPackageStartupMessages(library(dplyr))
opts <- bind_cols(dplyr::data_frame(model_name=opt_names), opts) %>%
  arrange(model_name)
knitr::kable(opts)
```
